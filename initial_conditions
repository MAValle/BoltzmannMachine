
# This function allows you to declare the initial conditions of the couplings and
# the magnetizations to start the learning process.

# Inputs:
# tipe: character indicanting one of the five alternatives:
# 
# a1 = couplings and megnetizations iqual to zero.
# a2 = couplings equal to the matrix input sij (correlation matrix) and 
#      magnetizations equal to vector si (averages of spins)
# a3 = couplings equal to the matrix input sij (correlation matrix) and 
#      magnetizations equal to  log(pi/(1-pi)) where p1 is the proportion
#      of spins in "on state" (1) of the ith variable.
#      In this case, input df (matrix with spins).
# a4 = couplings are zero and magnetizations equal to  log(pi/(1-pi)) where 
#      p1 is the proportion of spins in "on state" (1) of the ith variable.
#      In this case, input df (matrix with spins).
# a5 = couplings are random values from a normal disgtribution with zero mean
#      and standard deviation of "desv" (usually 0.05). Magnetizations
#      are zero.
# More Inputs:
#  * si y sij = average of spins (column means of input df) and correaltion
#      matrix of input df.
#  * df = original data matriz with spins  1 y -1.
#  * N = number of variables or nodes
#  * desv = standard deviation for tipe="a5".
#OUTPUTS:
#  * ho y J0 : vector and matrix for initial conditions of magnetizations and 
#    couplings respectively. 

initial_conditions <- function(df=NULL, N, tipe, si, sij, desv) {
  require(Matrix)
  if (tipe == 'a1') {
    h0 <- t(as.matrix(matrix(0L, nrow=1, ncol=N)))
    J0 <- matrix(0L, nrow=N, ncol=N) 
  } else if (tipe == 'a2') {
    h0 <- si
    J0 <- sij
  } else if (tipe == 'a3') {
    df = 0.5*df+0.5
    p = colSums(df)/nrow(df)
    h0 <- log(p/(1-p))
    J0 <- matrix(0L, nrow=N, ncol=N) 
  } else if (tipe == 'a4'){
    h0 <-matrix(0L, nrow=1, ncol=N)
    for (cl in c(1:N)) {
      s <- sum(df[,cl] == 1)
      p <- s/nrow(df)
      h0[1, cl] <- log(p/(1-p))
    }
    h0 <- t(as.matrix(h0))
    J0 <- matrix(0L, nrow=N, ncol=N) 
  } else if (tipe == 'a5') {
    h0 <- t(as.matrix(matrix(0L, nrow=1, ncol=N)))
    J0 <- matrix(runif(N*N, -1, 1),N )
    ind <- lower.tri(J0) 
    J0[ind] <- t(J0)[ind] 
    diag(J0) <- NA
  }
  return(list(h0, J0))
}
